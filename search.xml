<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于git flow 的理解</title>
      <link href="2017/05/19/%E5%85%B3%E4%BA%8Egit-flow-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>2017/05/19/%E5%85%B3%E4%BA%8Egit-flow-%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>关于git flow 的理解</p><p>最近公司搭建了git服务器，所以第一时间把项目切到了用git管理，然后就想使用git flow 来规范下流程。</p><a id="more"></a><h3 id="Git-Flow常用的分支"><a href="#Git-Flow常用的分支" class="headerlink" title="Git Flow常用的分支"></a>Git Flow常用的分支</h3><ul><li>Production 分支（受保护分支）</li></ul><p>也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改，开发人员也不要开放权限。</p><ul><li>Develop 分支</li></ul><p>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</p><ul><li>Feature 分支</li></ul><p>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p><ul><li>Release分支</li></ul><p>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</p><ul><li>Hotfix分支</li></ul><p>当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release</p><h3 id="Git-Flow如何工作"><a href="#Git-Flow如何工作" class="headerlink" title="Git Flow如何工作"></a>Git Flow如何工作</h3><ol><li><p>Master 分支</p><p>所有在Master分支上的Commit应该Tag</p></li><li><p>Feature 分支</p><p>Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留</p></li><li><p>Release 分支</p><p>Release分支基于Develop分支创建，打完Release分之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)</p><p>发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。</p></li></ol><p>4 .Hotfix 分支</p><p>​    hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag</p><p>​    大概的流程如上所述，刚开始的时候还是建议大家使用GUI ，方面快捷，主要还是要清楚各个分支的作用，和流程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLA 1.2 App审核解决方案</title>
      <link href="2017/05/11/PLA%201.2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2017/05/11/PLA%201.2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="PLA-1-2-App审核解决方案"><a href="#PLA-1-2-App审核解决方案" class="headerlink" title="PLA 1.2 App审核解决方案"></a>PLA 1.2 App审核解决方案</h3><p>最近提交App的时候遇到PLA 1.2 的问题，来来回回，浪费了不少时间，这里简单描述下经过，希望对大家有所帮助<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发件人 Apple</span><br><span class="line">Thank you for your resubmission. Upon further review, we continue to find the following issue unresolved:</span><br><span class="line">PLA 1.2The Seller and Artist names associated with your app do not reflect the name of the financial institute responsible for this app in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line">Next StepsYour app must be published under a Seller name and Artist name that reflects the name of the financial institute responsible for this app. If you have developed these apps on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.The Artist name is the Company name in iTunes Connect. For information on how to address this issue, please contact iTunes Connect Contact Us.</span><br></pre></td></tr></table></figure><p>Apple 的意思是要App name 要和company name 保持相近的名称，一开始比较着急，担心非要修改修改App  name 才能解决，以为我的App name 完全和公司不搭边，但是为了更加灵活， 我拨打了技术支持电话400-670-1855，他们说这边可以给他审核团队提供证明材料，证明该品牌在公司名下就可以了。这里我是提供的是申请商标的图片，商标名和App name 一致，拿到资料后，添加附件，让他们继续审核就可以啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Mantle高效构建model</title>
      <link href="2016/06/27/%E4%BD%BF%E7%94%A8Mantle%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAmodel/"/>
      <url>2016/06/27/%E4%BD%BF%E7%94%A8Mantle%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAmodel/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Mantle高效构建model"><a href="#使用Mantle高效构建model" class="headerlink" title="使用Mantle高效构建model"></a>使用Mantle高效构建model</h2><p>iOS 开发中，从服务器获取数据，然后解析成本地的模型是我们经常要做的事，而且重复次数特别的多，没次增加一个网路请求或增加一个模型都需要完成json–&gt;model的转换，手写<code>setValuesForKeysWithDictionary</code>:显然已更不上时代的步伐，所以我们说下如何高效构建model。<br><a id="more"></a><br>熟悉OC的朋友应该知道NSObject有一个方法，叫做<code>- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</code><br>这个方法就是利用kvc，直接让 model 调用 <code>- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</code> 方法，通过遍历传入的字典的key，对model进行赋值。<br>举个简单例子，现在我们有个Model叫做User。它的property和init方法如下。</p><pre><code>@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *address;- (id)initWithDictionary:(NSDictionary *)dict{    if (self = [super init]) {        [self setValuesForKeysWithDictionary:dict];    }    return self;}</code></pre><p>//然后我们这样给它赋值。   </p><pre><code>NSDictionary *dict = @{@&quot;name&quot;:@&quot;zql&quot;, @&quot;address&quot;:@&quot;beijing&quot;};User *user = [[User alloc] initWithDictionary:dict];NSLog(@&quot;User name is %@, address is %@&quot;, user.name, user.address);</code></pre><p>打印出来的结果就是 </p><pre><code>User name is zql, address is beijing</code></pre><p>但是，这里有可能会出现几个问题。<br>如果 Dictionary 里的某一个 key 的名字和Model里的property的名字不匹配，就会造成NSUnknownKeyException 然后直接崩溃。<br>没法进行类型判断，如果你的dictionary里某个key对应的值和你的model里相同的key对应的值得类型不一致，他没有办法自动转换，而且完全不会报错。<br>当然，你可能会说，第一个问题，可以通过实现<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>  这个方法来进行检测和修复。<br>但问题是，如果大量的key不匹配的话，你又回到了原来的问题，需要写大量重复的代码。</p><p>这样分析下来，直接使用 setValuesForKeysWithDictionary 并不能实现我们的需求。<br><!--more--></p><h3 id="Modle的基本用法"><a href="#Modle的基本用法" class="headerlink" title="Modle的基本用法"></a>Modle的基本用法</h3><p>自定义Model的时候都需要集成自MTLModel，并且实现MTLJSONSerializing协议，例如下面的:</p><pre><code>typedef NS_ENUM(NSUInteger, GHIssueState) {    GHIssueStateOpen,    GHIssueStateClosed};@interface GitIssueModel : MTLModel&lt;MTLJSONSerializing&gt;@property (strong, nonatomic,readonly) NSURL *URL;@property (nonatomic, copy, readonly) NSURL *HTMLURL;@property (nonatomic, copy, readonly) NSNumber *number;@property (nonatomic, assign, readonly) GHIssueState state;@property (nonatomic, copy, readonly) NSString *reporterLogin;@property (nonatomic, strong, readonly) GHUser *assignee;@property (nonatomic, copy, readonly) NSDate *updatedAt;@property (nonatomic, copy) NSString *title;@property (nonatomic, copy) NSString *body;@property (nonatomic, copy, readonly) NSDate *retrievedAt;@property (nonatomic, assign,readonly) BOOL isnew;@property (nonatomic, strong) NSArray *users;</code></pre><p>.m 文件  </p><pre><code>//处理这种 model 里的 key 和 字典里 key 不一致的情况+(NSDictionary *)JSONKeyPathsByPropertyKey {        return @{             @&quot;URL&quot;:@&quot;url&quot;,             @&quot;HTMLURL&quot;:@&quot;html_url&quot;,             @&quot;number&quot;:@&quot;number&quot;,             @&quot;state&quot;:@&quot;state&quot;,             //键值的合理映射             @&quot;reporterLogin&quot;:@&quot;assignee.login&quot;,             @&quot;assignee&quot;:@&quot;assignee&quot;,             @&quot;updatedAt&quot;:@&quot;update_at&quot;,             @&quot;title&quot;:@&quot;title&quot;,             @&quot;body&quot;:@&quot;body&quot;,             @&quot;isnew&quot;:@&quot;new&quot;,             @&quot;users&quot;:@&quot;users&quot;                          };}</code></pre><h2 id="NSValueTransformer"><a href="#NSValueTransformer" class="headerlink" title="NSValueTransformer"></a>NSValueTransformer</h2><p>Mantle还能够处理任意类型的转换，例如NSStringheNSNumber默认支持。然而，它也需要一些帮助对于处理非任意的类型例如NSURL和枚举还有自定义的结构体像CLLocationCoordinate2D。</p><p>Mantle依赖Foundation框架下NSValueTransformer对象来实现在模型代表的JSON层和OC对象的实际接口之间的值的映射。</p><p>创建一个自定义transformer给某个属性，我们需要实现一个叫做+<propertyname>JSONTransformer的类方法并且返回一个想要的NSValueTransformer对象。</propertyname></p><h2 id="NSURL-↔︎-JSON-string"><a href="#NSURL-↔︎-JSON-string" class="headerlink" title="NSURL ↔︎ JSON string"></a>NSURL ↔︎ JSON string</h2><pre><code>+ (NSValueTransformer *)URLJSONTransformer {    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];}+ (NSValueTransformer *)HTMLURLJSONTransformer {    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];}</code></pre><h2 id="BOOL-↔︎-JSON-boolean"><a href="#BOOL-↔︎-JSON-boolean" class="headerlink" title="BOOL ↔︎ JSON boolean"></a>BOOL ↔︎ JSON boolean</h2><pre><code>+ (NSValueTransformer *)isnewTransformer {    return [NSValueTransformer         valueTransformerForName:MTLBooleanValueTransformerName];}</code></pre><h2 id="enum-↔︎-JSON-string"><a href="#enum-↔︎-JSON-string" class="headerlink" title="enum ↔︎ JSON string"></a>enum ↔︎ JSON string</h2><pre><code>+ (NSValueTransformer *)stateJSONTransformer {    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{       @&quot;open&quot;:@(GHIssueStateOpen),       @&quot;closed&quot;:@(GHIssueStateClosed)       }];}</code></pre><h2 id="转成数组"><a href="#转成数组" class="headerlink" title="转成数组"></a>转成数组</h2><pre><code>+ (NSValueTransformer *)usersJSONTransformer {     return [MTLJSONAdapter arrayTransformerWithModelClass:GHUser.class];}</code></pre><h2 id="转成另一个对象"><a href="#转成另一个对象" class="headerlink" title="转成另一个对象"></a>转成另一个对象</h2><pre><code>+ (NSValueTransformer *)assigneeTransformer {    return [MTLJSONAdapter dictionaryTransformerWithModelClass:GHUser.class];}</code></pre><h2 id="日期转换"><a href="#日期转换" class="headerlink" title="日期转换"></a>日期转换</h2><pre><code>+ (NSValueTransformer *)updatedAtJSONTransformer {    return [MTLValueTransformer transformerUsingForwardBlock:^id(NSString *dateString, BOOL *success, NSError *__autoreleasing *error) {        return [self.dateFormatter dateFromString:dateString];    } reverseBlock:^id(NSDate *date, BOOL *success, NSError *__autoreleasing *error) {        return [self.dateFormatter stringFromDate:date];    }];}+ (NSDateFormatter *)dateFormatter {    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];    dateFormatter.locale = [[NSLocale alloc]initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];    dateFormatter.dateFormat = @&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&apos;Z&apos;&quot;;    return dateFormatter;}</code></pre><h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><pre><code>- (instancetype)initWithDictionary:(NSDictionary *)dictionaryValue error:(NSError **)error {    self = [super initWithDictionary:dictionaryValue error:error];    if (self == nil) return nil;        _updatedAt = [NSDate date];        return self;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mantle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITableViewCell 动态高度计算</title>
      <link href="2016/06/21/UITableViewCell-%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
      <url>2016/06/21/UITableViewCell-%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>平时的开发中我们打交道最多的的可能就是UITableVIew了，那今天我们就总结下其动态显示高度的多种解决方法<a id="more"></a></p><h4 id="Method-1-iOS-8为我们提供的方法"><a href="#Method-1-iOS-8为我们提供的方法" class="headerlink" title="Method 1 -  iOS 8为我们提供的方法"></a>Method 1 -  iOS 8为我们提供的方法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> self.tableView.rowHeight = UITableViewAutomaticDimension;</span><br><span class="line"></span><br><span class="line"> 或者我们可以实现返回高度的代理方法</span><br><span class="line"> </span><br><span class="line"> - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">return UITableViewAutomaticDimension；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-systemLayoutSizeFittingSize"><a href="#Method-2-systemLayoutSizeFittingSize" class="headerlink" title="Method 2 - systemLayoutSizeFittingSize"></a>Method 2 - systemLayoutSizeFittingSize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGSize size = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];</span><br><span class="line">return 1  + size.height;</span><br></pre></td></tr></table></figure><blockquote><p>如果说我们的UILable要多行显示的话要设置numberOfLines等于0，<br>    xib的话还要设置UIlable的preferredMaxLayoutWidth</p></blockquote><h4 id="Method-3-sizeWithFont"><a href="#Method-3-sizeWithFont" class="headerlink" title="Method 3 - sizeWithFont"></a>Method 3 - sizeWithFont</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeWithFont:(UIFont *)font </span><br><span class="line">constrainedToSize:(CGSize)size </span><br><span class="line">    lineBreakMode:(NSLineBreakMode)lineBreakMode</span><br></pre></td></tr></table></figure><blockquote><p>由于该方法在iOS7之后已经弃用我们可以用其替代方法来计算字符串的高度</p></blockquote><h4 id="Method-4-第三方库"><a href="#Method-4-第三方库" class="headerlink" title="Method 4 - 第三方库"></a>Method 4 - 第三方库</h4><p>大家应该熟知早前在百度知道团队的哥们的一个库UITableView-FDTemplateLayoutCell（runtime + method swizzing实现）   </p><blockquote><p>详情请参考Demo-<a href="https://github.com/LargeShrimp/UITableViewCellDynamicHeight" target="_blank" rel="noopener">https://github.com/LargeShrimp/UITableViewCellDynamicHeight</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cell高度计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hit-Testing</title>
      <link href="2016/06/04/hit-Testing/"/>
      <url>2016/06/04/hit-Testing/</url>
      
        <content type="html"><![CDATA[<p>扩大按钮的点击区域</p><p>在iOS事件响应则链中，<br>当用户UIApplication 单例就会从事件队列中去取最新的事件，然后分发给能够处理该事件的对象。UIApplication 获取到Event之后，Application就纠结于到底要把这个事件传递给谁，这时候就要依靠HitTest来决定了。<a id="more"></a></p><p>iOS中，hit-Testing的作用就是找出这个触摸点下面的View是什么，HitTest会检测这个点击的点是不是发生在这个View上，如果是的话，就会去遍历这个View的subviews，直到找到最小的能够处理事件的view，如果整了一圈没找到能够处理的view，则返回自身。</p><p>UIView中提供两个方法用来确定hit-testing View,如下所示 </p><ul><li><p>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event; - // recursively calls -pointInside:withEvent:. point is in the receiver’s coordinate system</p></li><li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; // default returns YES if point is in bounds</p></li></ul><p>当一个View收到hitTest消息时，会调用自己的pointInside:withEvent:方法,如果pointInside返回YES，则表明触摸事件发生在我自己内部，则会遍历自己的所有Subview去寻找最小单位(没有任何子view)的UIView，</p><p>重点，hit-Test判断的区域是view的bounds，所以我们可以通过扩大view的buounds = reactA，然后在判断如果手势点在扩大后的区域内，就返回该视图即可。</p><p>分析其源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. 通过分类的方式给UIButton 扩展方法，</span><br><span class="line">2. 利用runtime为UIButton扩展四个属性 ，top ，left，bottom，right 。</span><br><span class="line"></span><br><span class="line">- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left</span><br><span class="line">&#123;</span><br><span class="line">    //赋值</span><br><span class="line">    objc_setAssociatedObject(self, &amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, &amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, &amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, &amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">3. 利用hit-Test在超出的区域内返回该视图(扩大按钮的bounds)</span><br><span class="line">- (CGRect) enlargedRect</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber* topEdge = objc_getAssociatedObject(self, &amp;topNameKey);</span><br><span class="line">    NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;rightNameKey);</span><br><span class="line">    NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;bottomNameKey);</span><br><span class="line">    NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;leftNameKey);</span><br><span class="line">    </span><br><span class="line">    if (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge)</span><br><span class="line">    &#123;</span><br><span class="line">        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,</span><br><span class="line">                          self.bounds.origin.y - topEdge.floatValue,</span><br><span class="line">                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</span><br><span class="line">                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return self.bounds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检测出发点是否在接受视图的坐标系统中</span><br><span class="line">- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event</span><br><span class="line">&#123;</span><br><span class="line">    CGRect rect = [self enlargedRect];</span><br><span class="line">    if (CGRectEqualToRect(rect, self.bounds))</span><br><span class="line">    &#123;</span><br><span class="line">        return [super hitTest:point withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">    return CGRectContainsPoint(rect, point) ? self : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hit-Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中坐标转换</title>
      <link href="2016/06/01/iOS%E4%B8%AD%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
      <url>2016/06/01/iOS%E4%B8%AD%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>我们在开发中经常用到坐标系统的转换，比如获取某个cell相对与self.view的坐标，获取scrollview上某个item的坐标。iOS系统中提供给我们用于坐标系统转换的方法如下<a id="more"></a>   </p><ul><li>(CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view     </li><li>(CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view     </li><li>(CGRect)convertRect:(CGRect)rect fromView:(UIView *)view    </li><li>(CGRect)convertRect:(CGRect)rect toView:(UIView *)view   </li></ul><p>fromView是从目标坐标系转换到调用convertXXXX的视图坐标系。如果fromView为空的话，它的坐标将会使用整个窗口的坐标系，也可以理解成屏幕空间的坐标系。</p><p>toView是从调用convertXXXX的视图坐标系转换到目标坐标系。如果toView为空的话，它的坐标将会使用整个窗口的坐标系，也可以理解成屏幕空间的坐标系。</p><p>如图<br><img src="http://ww3.sinaimg.cn/large/809fd07fjw1f4g4fuudrzj20gs0fqt9d.jpg" alt></p><p> viewA frame (10,10,200,200)<br> viewB frame (30,30,140,140)<br> viewC frame (20,20,100，100)   </p><p>示例代码如下   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGRect frameA = self.viewA.frame;   </span><br><span class="line">CGRect frameB = self.viewB.frame;   </span><br><span class="line">CGRect frameC = self.viewC.frame;   </span><br><span class="line">CGPoint centerB = self.viewB.center;   </span><br><span class="line">    </span><br><span class="line">// 从self.viewB的坐标系统转换到self.view的坐标系统</span><br><span class="line">CGPoint pointA = [self.viewB convertPoint:self.viewB.center toView:self.view];</span><br><span class="line">//pointA = (x = 140, y = 140)</span><br><span class="line"></span><br><span class="line">//    Converts a rectangle from the receiver’s coordinate system to that of another view.</span><br><span class="line">//注意这里的react 不是bounds 而是frame</span><br><span class="line">CGRect reactA = [self.viewA convertRect:frameB toView:self.view];</span><br><span class="line">//reactA = (origin = (x = 40, y = 40), size = (width = 140, height = 140))</span><br><span class="line"></span><br><span class="line">CGPoint pointC = [self.view convertPoint:self.viewC.center fromView:self.viewB];</span><br><span class="line">//pointC = (x = 110, y = 110)</span><br><span class="line"></span><br><span class="line">CGRect reactC = [self.view convertRect:frameC fromView:self.viewB];</span><br><span class="line">//reactC = (origin = (x = 60, y = 60), size = (width = 100, height = 100))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坐标转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIRefreshControl 实现简单的下拉刷新</title>
      <link href="2016/04/30/UIRefreshControl/"/>
      <url>2016/04/30/UIRefreshControl/</url>
      
        <content type="html"><![CDATA[<p>UIRefreshControl </p><p>先看下官方的解释<br><em>A UIRefreshControl object provides a standard control that can be used to initiate the refreshing of a table view’s contents.</em><br>所以这种方法只适用于<code>UITableView</code>和<code>UITableViewController</code><br><a id="more"></a><br>UIRefreshControl是一个iOS中并不常用的开发控件，由于他继承至UIView,所以我们可以为其添加自定义试图来实现自定义刷新。<br>代码如下：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UIView *refreshView = [[UIView alloc] initWithFrame:CGRectMake(0, 55, 0, 0)];</span><br><span class="line">   refreshView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">   [self.tableView insertSubview:refreshView atIndex:0];</span><br><span class="line">   </span><br><span class="line">   [refreshView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">       make.height.equalTo(@55);</span><br><span class="line">       make.left.and.right.and.top.equalTo(self.tableView);</span><br><span class="line">   &#125;];</span><br><span class="line">   self.refreshControl = [[UIRefreshControl alloc] init];</span><br><span class="line">   self.refreshControl.tintColor = [UIColor clearColor];</span><br><span class="line">   [self.refreshControl addTarget:self action:@selector(reloadDatas) forControlEvents:UIControlEventValueChanged];</span><br><span class="line">   </span><br><span class="line">   [refreshView addSubview:self.refreshControl];</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   self.refreshLoadingView = [[UIView alloc] initWithFrame:self.refreshControl.bounds];</span><br><span class="line">   self.refreshLoadingView.backgroundColor = [UIColor clearColor];;</span><br><span class="line">   [self.refreshControl addSubview:self.refreshLoadingView];</span><br><span class="line">   </span><br><span class="line">   [self.refreshLoadingView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">       make.edges.equalTo(self.refreshControl);</span><br><span class="line">   &#125;];</span><br><span class="line">   self.tipsLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 320, 55)];</span><br><span class="line">   self.tipsLabel.font = [UIFont systemFontOfSize:14.0f];</span><br><span class="line">   self.tipsLabel.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">   self.tipsLabel.textColor = [UIColor colorWithWhite:0.424 alpha:1.000];</span><br><span class="line">   </span><br><span class="line">   [self.refreshLoadingView addSubview:self.tipsLabel];</span><br><span class="line">   </span><br><span class="line">   [self.tipsLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">       make.edges.equalTo(self.refreshLoadingView);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>当滚动到tableView 的底部时，通过监听 contentoffset.y 的值，我们判断是是否加载”图文详情”,也就是触发底部刷新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123;</span><br><span class="line">    if (scrollView.contentOffset.y + scrollView.frame.size.height &gt;= scrollView.contentSize.height) &#123;</span><br><span class="line">        NSLog(@&quot;不要拽我。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们用 a = scrollView.contentOffset.y, b = scrollView.frame.size.height , c = scrollView.contentSize.height</p><p> 重点：我们要找个他们的三个之间的关系 a 为偏移量， b 为tableView 的高度，c 为tableView 的最大滚动区域， 他们之间有一个临界点 a + b = c 时， tableView 刚好滚到底部。所以我们可以在 a + b &gt; c的 时候触发事件去加载detailTableView.</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 下拉刷新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stackoverflow tips</title>
      <link href="2016/01/16/stackoverflow-tips/"/>
      <url>2016/01/16/stackoverflow-tips/</url>
      
        <content type="html"><![CDATA[<ol><li><p>隐藏导航栏的返回按钮   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationItem setHidesBackButton:YES animated:YES]    </span><br><span class="line">或者   </span><br><span class="line">[self.navigationItem setHidesBackButton:YES];</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>mac 显示/隐藏文件   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles True</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles No</span><br></pre></td></tr></table></figure></li></ol><!--more-->    <ol start="3"><li><p>注销通知</p><p> 可以在vc 里的dealloc 中，但是不要调用的父类的dealloc 方法</p></li><li><p>改变按钮的响应事件   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://stackoverflow.com/questions/8281377/selector-for-cancel-button-works-differently-fr...</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>判断设备是否越狱   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isJailbroken &#123;</span><br><span class="line">    BOOL jailbroken = NO;</span><br><span class="line">    NSString *cydiaPath = @&quot;/Applications/Cydia.app&quot;;</span><br><span class="line">    NSString *aptPath = @&quot;/private/var/lib/apt/&quot;;</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) &#123;</span><br><span class="line">        jailbroken = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) &#123;</span><br><span class="line">        jailbroken = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return jailbroken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ActionSheetPicker-3.0</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/skywinder/ActionSheetPicker-3.0</span><br></pre></td></tr></table></figure></li><li><p>改变textfield的borderColor</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textfield.borderWidth = 1.0f;</span><br><span class="line">textfield.layer.borderColor = [UIColor redColor].CGColor;</span><br></pre></td></tr></table></figure></li><li><p>改变textfield 的height  in sb or xib</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给其加一个 height 约束，然后修改约束的高度</span><br><span class="line">http://stackoverflow.com/questions/8641557/how-set-uitextfield-height</span><br></pre></td></tr></table></figure></li><li><p>limiting text field input  限制textfield输入长度   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    NSString *newString = [textField.text stringByReplacingCharactersInRange:range withString:string];</span><br><span class="line">    return !([newString length] &gt; 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CocoaPods 升级慢问题</p><p>CocoaPods pod install/pod update更新慢的问题<br>最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动了，令人甚是DT。</p><p>查了好多的资料，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod install --verbose --no-repo-update</span><br><span class="line">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure></li><li><p>reveal debug   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Reveal-iOS-SDK&apos;, :configurations =&gt; [&apos;Debug&apos;]</span><br></pre></td></tr></table></figure></li><li><p>Status bar and navigation bar appear over my view’s bounds in iOS 7<br><a href="http://stackoverflow.com/questions/17074365/status-bar-and-navigation-bar-appear-over-my-views-bounds-in-ios-7" target="_blank" rel="noopener">@链接</a></p></li></ol><ol start="13"><li><p>改变tableview cel 左边和右边的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [_tableView setBackgroundView:nil];</span><br><span class="line">_tableView.backgroundColor = [UIColor clearColor];</span><br></pre></td></tr></table></figure></li><li><p>url 中含有中文的时候进行 utf-8 转码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure></li><li><p>导航控制器的titleView   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *titleImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 69, 22)];</span><br><span class="line">   titleImageView.image = [UIImage imageNamed:@&quot;logo&quot;];</span><br><span class="line">   self.navigationItem.titleView = titleImageView;</span><br></pre></td></tr></table></figure></li><li><p>如何得到storyboard   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIStoryboard *st = [UIStoryboard storyboardWithName:[[NSBundle mainBundle].infoDictionary objectForKey:@&quot;UIMainStoryboardFile&quot;] bundle:[NSBundle mainBundle]];</span><br></pre></td></tr></table></figure></li><li><p>cell 分割线铺满（去掉inset）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Remove seperator inset</span><br><span class="line">     if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123;</span><br><span class="line">         [cell setSeparatorInset:UIEdgeInsetsZero];</span><br><span class="line">     &#125;</span><br><span class="line">     // Prevent the cell from inheriting the Table View&apos;s margin settings</span><br><span class="line">     if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123;</span><br><span class="line">         [cell setPreservesSuperviewLayoutMargins:NO];</span><br><span class="line">     &#125;</span><br><span class="line">     // Explictly set your cell&apos;s layout margins</span><br><span class="line">     if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123;</span><br><span class="line">         [cell setLayoutMargins:UIEdgeInsetsZero];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>xcode 关掉https</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xcode7不支持http通信，需要在plist增加一个字段以支持http </span><br><span class="line">1.在Info.plist中添加NSAppTransportSecurity类型Dictionary。</span><br><span class="line">2.在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES</span><br></pre></td></tr></table></figure></li><li><p>How do I remove local (untracked) files from my current Git branch?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f -n</span><br></pre></td></tr></table></figure></li><li><p>UIWebView into a UITableViewCell with dynamic size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://stackoverflow.com/questions/28709899/uiwebview-into-a-uitableviewcell-with-dynamic-size</span><br></pre></td></tr></table></figure></li><li><p>Undefined symbols for architecture armv7:<br>有这个文件，但是compile sources 中没有该文件    </p></li><li><p>隐藏返回的按钮的文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)</span><br><span class="line"> forBarMetrics:UIBarMetricsDefault];</span><br></pre></td></tr></table></figure></li><li><p>lldb 调试 p不出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr @import UIKit</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stackoverflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Objective-C 2.0 读书笔记</title>
      <link href="2015/09/04/Effective%20Obejct-C%202.0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2015/09/04/Effective%20Obejct-C%202.0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>记：这种进阶类的书记，每次拿来阅读都会有不一样的理解，每次的专注点也会不一样，这也许就是成长。本笔记目的是强化自己的理解，便于以后能快速查找。<br><a id="more"></a></p><ol><li><p>oc 是有smalltall 演化而来，动态绑定</p></li><li><p>理解 c 内存模型</p><p> 对象都在堆上，手动管理</p></li><li><p>在类的头文件中尽量少的引入其他头文件（@class）<br>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合（coupling）.<br>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，应尽量把“该类遵循某协议”的这条声明移至“class-continuation分类中”。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。<br>3.多使用字面量常量 ，字面量常量对象都是不可变得，使用可使用mutablecopy</p></li><li><p>多用类型常量（带类型信息），少用预处理命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define ANIAMTION_DURATION  0.3   </span><br><span class="line">static const NSTimeInterval kAnimationDuration  = 0.3   </span><br><span class="line">(只在编译单元可见)   </span><br><span class="line">extern NSString * const EOCStringConstant;  （公开）</span><br><span class="line">在实现文件中  NSString * const EOCStringConstant = @“hello”;</span><br></pre></td></tr></table></figure></li><li><p>用枚举表示状态，选项和状态码<br>枚举和switch 使用时不需要default 分支</p></li><li><p>理解属性的概念</p><p> @dynamic  编译器不会为这个属性自动生成存取方法或实例变量（_firstName）</p><p> readonly  若某属性仅可于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性<br> 当我们声明一个 readonly 的属性，外部可能会通过 KVC 修改该属性值。<br> 为了避免 KVC 修改属性值，须将定义属性所在类的类方法 + (BOOL)accessInstanceVariablesDirectly 重写，使其返回 NO.</p><p> assign  基本数据类型<br> strong 拥有关系 保留新值，释放旧值，并把新值设置上去<br> weak 非拥有关系，既不保留新值，也不释放旧值（同assign）,当所指对象销毁时，自动至为nil<br> copy 同strong 类似，然后并不会保留新值，而是copy 一份</p></li><li><p>在对象内部尽量直接访问实例变量、</p><ul><li>直接访问不会触发kvo，不会触发存取方法</li><li>懒加载的时候要使用属性访问</li><li>dealloc的时候使用直接访问</li></ul></li><li><p>以“类族模式”隐藏实现细节</p><ul><li>系统框架中经常使用类族</li><li>类族模式可以把实现细节隐藏在一套简单的公共接口后面</li></ul></li><li><p>在既有类中使用<em>关联对象</em>存放自定义数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置关联对象</span><br><span class="line">void  objc_setAssociatedObject (id object, void * key, id value, objc_associationPolicy policy)</span><br><span class="line">获取关联对象的值</span><br><span class="line">id objc_getAssociatedObejct(id obejct, void *key)</span><br><span class="line">移除指定对象的全部关联对象</span><br><span class="line">void objc_removeAssociatedObejcts(id obejct)</span><br></pre></td></tr></table></figure><p>举个栗子</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static void *EOCMyAlertViewKey = @&quot;EOCMyAlertViewKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)askUserAQuestion &#123;</span><br><span class="line"></span><br><span class="line"> UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;Question&quot;</span><br><span class="line">                                                          message:@&quot;What do you want to do?&quot;</span><br><span class="line">                                                         delegate:self</span><br><span class="line">                                                cancelButtonTitle:@&quot;取消&quot;</span><br><span class="line">                                                otherButtonTitles:@&quot;继续&quot;, nil];</span><br><span class="line">void (^block)(NSInteger buttonIdx) = ^(NSInteger buttonIdx) &#123;</span><br><span class="line">    </span><br><span class="line">        if (buttonIdx == 0) &#123;</span><br><span class="line">            // cancle</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //sure</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line">objc_setAssociatedObject(alertView, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">    </span><br><span class="line">    [alertView show];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)alertView:(UIAlertView *)alertView</span><br><span class="line">clickedButtonAtIndex:(NSInteger)buttonIndex &#123;</span><br><span class="line">    </span><br><span class="line">   void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class="line">   block(buttonIndex);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以通过关联对象把两个对象关联起来</li><li>定义关联对象的时候可指定内存管理语义</li><li>只有在其他办法不可行的时候才选用关联对象</li></ul><ol start="13"><li><p>用“方法调配技术”调试“黑盒方法” （ method swizzling ）</p><p>举个🌰</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIViewController+Tracking.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation UIViewController (Tracking)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    </span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line">    Class class = [self  class];</span><br><span class="line">    SEL originSelector = @selector(viewWillAppear:);</span><br><span class="line">    SEL swizzledSelector  = @selector(rh_viewWillAppear:);</span><br><span class="line">    </span><br><span class="line">    Method originalMenthod = class_getInstanceMethod(class, originSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    //添加新方法</span><br><span class="line">    BOOL didAddMethod = class_addMethod(class, originSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //如果已经添加，就方法替换</span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        //Replaces the implementation of a method for a given class.</span><br><span class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMenthod), method_getTypeEncoding(originalMenthod));</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMenthod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)rh_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">[self rh_viewWillAppear:animated];</span><br><span class="line">NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在运行期可以向类中新增或者替换选择子所对应的方法实现</em></p><ol start="14"><li><p>理解类对象的用意</p><ul><li>每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。</li><li>如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知</li><li>尽量使用类型查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能（不懂）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isKindOfClass 判断对象是否为某些类或其派生类的实例</span><br><span class="line">isMeberOfClass 判断出对象是否为某个特定类的实例</span><br></pre></td></tr></table></figure></li><li><p>用前缀避免命名空间冲突</p></li><li>提供<em>全能初始化方法</em> </li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解block（块）</title>
      <link href="2015/04/19/%E7%90%86%E8%A7%A3block/"/>
      <url>2015/04/19/%E7%90%86%E8%A7%A3block/</url>
      
        <content type="html"><![CDATA[<hr><p>block的结构图<br><a id="more"></a><br><img src="http://ww1.sinaimg.cn/large/809fd07fgw1erb980sqr6j20vo0brtbe.jpg" alt="block结构图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type (^block_name)(paratemters)</span><br></pre></td></tr></table></figure><h4 id="block的基本用法"><a href="#block的基本用法" class="headerlink" title="block的基本用法"></a>block的基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int additional = 5;</span><br><span class="line">int (^addBlock)(int a, int b) = ^(int a, int b)&#123;</span><br><span class="line">return a + b+ addition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认情况下，为block所捕获的变量，是不可以在块里修改的-需要加-block"><a href="#默认情况下，为block所捕获的变量，是不可以在块里修改的-需要加-block" class="headerlink" title="默认情况下，为block所捕获的变量，是不可以在块里修改的(需要加__block)"></a>默认情况下，为block所捕获的变量，是不可以在块里修改的(需要加__block)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@0, @1, @2, @3, @4, @5];</span><br><span class="line"></span><br><span class="line">__block int count = 0;</span><br><span class="line">   </span><br><span class="line">[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">       </span><br><span class="line">       if ([number compare:@2] == NSOrderedAscending) &#123;</span><br><span class="line">           </span><br><span class="line">           count ++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">//    count = 2;</span><br></pre></td></tr></table></figure><p> 块总能修改实例变量，所以在声明时无需加__block</p><p>####在定义blcok的时候，所占内存分配的栈中的，这就是说，块只在定义他的那个范围内有效</p><p><strong><em>一下代码就很危险</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line">    </span><br><span class="line">if (count == 2) &#123;</span><br><span class="line">    </span><br><span class="line">    block = ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Block A&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    </span><br><span class="line">     block = ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Block B&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>首先栈内存是分配是有编译器分配和释放的，以上代码中if和else中的block被分配到栈内存中（这两个块只能保证在对应的if或else语句范围内有效），如果编译器把分配给block的内存给覆写掉，那么程序就会崩溃。<br>注意：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来讲，释放工作有程序员控制，容易产生memory Leak。<br>为解决以上问题，我们可以给block对象发送copy消息，把block从栈复制到堆上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line"> </span><br><span class="line">if (count == 2) &#123;</span><br><span class="line"> </span><br><span class="line"> [block = ^&#123;</span><br><span class="line">     </span><br><span class="line">     NSLog(@&quot;Block A&quot;);</span><br><span class="line">     </span><br><span class="line"> &#125; copy];</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> </span><br><span class="line"> [block  =^&#123;</span><br><span class="line"> </span><br><span class="line">  NSLog(@&quot;Block B&quot;);</span><br><span class="line"> </span><br><span class="line"> &#125; copy];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block();</span><br></pre></td></tr></table></figure><h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>可以把块定义为全局变量，在文件级别上使用。全局块可以声明到全局内存中，而不需要在每次用到得时候于栈中创建。另外全局块的copy是个空操作，因为全局块绝不可能为系统所回收。</p><p>block一般有三种，NSConcreteGlobal, NSConcreteStack, NSConcreteMalloc。<br>block是可以访问block外部的变量的。<br>NSConcreteGlobal: 就像一个全局函数一样，从头到尾待在那，始终是可用的。当Block中没有引用外部变量时，block为global类型的。<br>NSConcreteStack: 保存在栈中的block，block执行完后内存会被释放掉。当block引用了外部变量时，block为stack类型的。<br>NSConcreteMallock: 保存在堆中的block，block为引用记数为0时，内存会被释放掉。当block执行copy时，block会从栈中复制到堆中。<br>以上都针对非ARC环境而言，如果在ARC环境下，引用外部变量的block会自动保存在堆中，无需copy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待续。。。</span><br></pre></td></tr></table></figure><blockquote><p>block的理解<a href="http://answerhuang.duapp.com/index.php/2013/09/07/objective-c-blocks-syntax/#carousel-generic-38" target="_blank" rel="noopener">http://answerhuang.duapp.com/index.php/2013/09/07/objective-c-blocks-syntax/#carousel-generic-38</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoLayout用法（一）</title>
      <link href="2015/04/04/AutoLayout%E7%94%A8%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2015/04/04/AutoLayout%E7%94%A8%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>今天介绍下用<code>AutoLauout</code>实现<code>等距约束</code>。</p><p>####先看下效果图</p><p><img src="http://ww3.sinaimg.cn/large/809fd07fjw1eqtk5o2rs4j21kw0yoq5a.jpg" alt="nihao"></p><a id="more"></a><h4 id="创建一个带view的xib文件"><a href="#创建一个带view的xib文件" class="headerlink" title="创建一个带view的xib文件"></a>创建一个带view的xib文件</h4><p>在Attibute inspector 设置status bar为none ,size 为freeform 这里我只考虑竖屏，所以size classes我们选择 (高度设置成100吧)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//适配所有iphone竖屏</span><br><span class="line">w:compact h:regular</span><br></pre></td></tr></table></figure><h4 id="创建我们需要4个UIButton和5个UIView-辅助视图，就是button之间的间距"><a href="#创建我们需要4个UIButton和5个UIView-辅助视图，就是button之间的间距" class="headerlink" title="创建我们需要4个UIButton和5个UIView(辅助视图，就是button之间的间距)"></a>创建我们需要4个UIButton和5个UIView(辅助视图，就是button之间的间距)</h4><p>其中按钮我们是正方形w:75 ,这里需要等宽等高（宽和高都为75，定值），当屏幕变化的时候，不能改变按钮的大小，辅助view呢，为了满足按钮间的间距相等，所以五个view呢我们希望他们左右的约束为0，宽度始终相同。</p><h4 id="给按钮添加约束"><a href="#给按钮添加约束" class="headerlink" title="给按钮添加约束"></a>给按钮添加约束</h4><p><img src="http://ww3.sinaimg.cn/large/809fd07fjw1eqtky4dlo3g20q30i2q9i.gif" alt="按钮等宽等高"></p><h4 id="给view设置等宽，再加一个高度"><a href="#给view设置等宽，再加一个高度" class="headerlink" title="给view设置等宽，再加一个高度"></a>给view设置等宽，再加一个高度</h4><p><img src="http://ww2.sinaimg.cn/large/809fd07fjw1eqtm6uahhzg20uk0i14kk.gif" alt="给view设置等宽"></p><h4 id="让他们的上下边距相等，左右边距为0"><a href="#让他们的上下边距相等，左右边距为0" class="headerlink" title="让他们的上下边距相等，左右边距为0"></a>让他们的上下边距相等，左右边距为0</h4><p><img src="http://ww3.sinaimg.cn/large/809fd07fjw1eqtmkwt700g20uk0ibqv7.gif" alt="边距相等"></p><h4 id="最后在preview中查看个尺寸的效果"><a href="#最后在preview中查看个尺寸的效果" class="headerlink" title="最后在preview中查看个尺寸的效果"></a>最后在preview中查看个尺寸的效果</h4><p><img src="http://ww3.sinaimg.cn/large/809fd07fjw1eqtmwxp5agg20xa0jk4qp.gif" alt="preview"><br>7.效果出来后就把view设置成透明即可。</p><blockquote><p>关于Size classes 和 AutoLayout 可以查考</p></blockquote><blockquote><ol><li>Size classes自悟 <a href="http://www.cocoachina.com/ios/20141217/10669.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20141217/10669.html</a><br></li><li>Working with Constraints in Interface Builder <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraints/WorkingwithConstraints.html" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraints/WorkingwithConstraints.html</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大中枢派发</title>
      <link href="2015/01/04/%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91/"/>
      <url>2015/01/04/%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="大中枢派发"><a href="#大中枢派发" class="headerlink" title="大中枢派发"></a>大中枢派发</h3><p><em>关于ios 多线程看这篇就够了</em>   </p><h4 id="一、多线程背景"><a href="#一、多线程背景" class="headerlink" title="一、多线程背景"></a>一、多线程背景</h4><p>谈到iOS多线程，一般都会谈到四种方式：pthread、NSThread、GCD和NSOperation。其中，苹果推荐也是我们最经常使用的无疑是GCD,所以这里记录下GCD 在iOS常用用法。<br><a id="more"></a></p><ol><li><p>直接操纵线程实现多线程的<strong>弊端</strong>：</p><ul><li>开发人员必须根据系统的变化动态调整线程的数量和状态，即对开发者的负担重。   </li><li>应用程序会在创建和维护线程上消耗很多成本，即效率低。   </li></ul></li><li><p>GCD是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。GCD的工作方式，使其拥有很多优点（快、稳、准）：</p><ul><li>快，更快的内存效率，因为线程栈不暂存于应用内存。</li><li>稳，提供了自动的和全面的线程池管理机制，稳定而便捷。</li><li>准，提供了直接并且简单的调用接口，使用方便，准确。   </li></ul></li></ol><h4 id="二、队列和任务"><a href="#二、队列和任务" class="headerlink" title="二、队列和任务"></a>二、队列和任务</h4><ol><li>队列<br>调度队列是一个对象，它会以first-in、first-out的方式管理您提交的任务。GCD有三种队列类型：</li></ol><ul><li>串行队列，串行队列将任务以先进先出(FIFO)的顺序来执行，所以串行队列经常用来做访问某些特定资源的同步处理。你可以也根据需要创建多个队列，而这些队列相对其他队列都是并发执行的。换句话说，如果你创建了4个串行队列，每一个队列在同一时间都只执行一个任务，对这四个任务来说，他们是相互独立且并发执行的。如果需要创建串行队列，一般用dispatch_queue_create这个方法来实现，并指定队列类型DISPATCH_QUEUE_SERIAL。</li><li>并行队列，并发队列虽然是能同时执行多个任务，但这些任务仍然是按照先到先执行(FIFO)的顺序来执行的。并发队列会基于系统负载来合适地选择并发执行这些任务。并发队列一般指的就是全局队列(Global queue)，进程中存在四个全局队列：高、中(默认)、低、后台四个优先级队列，可以调用dispatch_get_global_queue函数传入优先级来访问队列。当然我们也可以用dispatch_queue_create，并指定队列类型DISPATCH_QUEUE_CONCURRENT，来自己创建一个并发队列。</li><li>主队列，与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。<br>额外说一句，上面也说过，队列间的执行是并行的，但是也存在一些限制。比如，并行执行的队列数量受到内核数的限制，无法真正做到大量队列并行执行；比如，对于并行队列中的全局队列而言，其存在优先级关系，执行的时候也会遵循其优先顺序，而不是并行。</li></ul><ol start="2"><li><p>任务<br>linux内核中的任务的定义是描述进程的一种结构体，而GCD中的任务只是一个代码块，它可以指一个block或者函数指针。根据这个代码块添加进入队列的方式，将任务分为同步任务和异步任务：</p><ul><li>同步任务，使用dispatch_sync将任务加入队列。将同步任务加入串行队列，会顺序执行，一般不这样做并且在一个任务未结束时调起其它同步任务会死锁。将同步任务加入并行队列，会顺序执行，但是也没什么意义。</li><li>异步任务，使用dispatch_async将任务加入队列。将异步任务加入串行队列，会顺序执行，并且不会出现死锁问题。将异步任务加入并行队列，会并行执行多个任务，这也是我们最常用的一种方式。</li></ul></li><li><p>简单应用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 队列的创建，queue1:中（默认）优先级的全局并行队列、queue2:主队列、queue3:未指定type则为串行队列、queue4:指定串行队列、queue5:指定并行队列</span><br><span class="line">dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_get_main_queue();</span><br><span class="line">dispatch_queue_t queue3 = dispatch_queue_create(&quot;queue3&quot;, NULL);</span><br><span class="line">dispatch_queue_t queue4 = dispatch_queue_create(&quot;queue4&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue5 = dispatch_queue_create(&quot;queue5&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">// 队列中添加异步任务</span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">// 任务</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 队列中添加同步任务</span><br><span class="line">dispatch_sync(queue1, ^&#123;</span><br><span class="line">// 任务</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、GCD常见用法和应用场景"><a href="#三、GCD常见用法和应用场景" class="headerlink" title="三、GCD常见用法和应用场景"></a>三、GCD常见用法和应用场景</h4><ol><li><p>dispatch_async</p><p> <strong><em>应用场景<br> 这种用法非常常见，比如开启一个异步的网络请求，待数据返回后返回主队列刷新UI；又比如请求图片，待图片返回刷新UI等等。</em></strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(globalQueue, ^&#123;</span><br><span class="line">    // 一个异步的任务，例如网络请求，耗时的文件操作等等</span><br><span class="line">    ...</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // UI刷新</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>dispatch_after </p></li></ol><p><strong><em>延时执行</em></strong>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue= dispatch_get_main_queue();</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">    // 在queue里面延迟执行的一段代码</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">3. dispatch_once 单例</span><br></pre></td></tr></table></figure><pre><code>static dispatch_once_t onceToken;</code></pre><p>dispatch_once(&amp;onceToken, ^{<br>    // 只执行一次的任务<br>    …<br>});</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. dispatch_group  组队列</span><br></pre></td></tr></table></figure>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^{    // 异步任务1});dispatch_group_async(group, queue, ^{    // 异步任务2});// 等待group中多个异步任务执行完毕，做一些事情，介绍两种方式// 方式1（不好，会卡住当前线程）dispatch_group_wait(group, DISPATCH_TIME_FOREVER);...// 方式2（比较好）dispatch_group_notify(group, mainQueue, ^{    // 任务完成后，在主队列中做一些操作    ...});<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** </span><br><span class="line">应用场景</span><br><span class="line">上述的一种方式，可以适用于自己维护的一些异步任务的同步问题；但是对于已经封装好的一些库，比如AFNetworking等，我们不获取其异步任务的队列，这里可以通过一种计数的方式控制任务间同步，下面为解决单界面多接口的一种方式。</span><br><span class="line">***</span><br></pre></td></tr></table></figure></code></pre><p>  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>    dispatch_group_t group = dispatch_group_create();</p><pre><code>dispatch_group_enter(group);dispatch_group_async(group, queue, ^{    // 异步任务1    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        NSLog(@&quot;异步任务1&quot;);        dispatch_group_leave(group);    });});dispatch_group_enter(group);dispatch_group_async(group, queue, ^{    // 异步任务2        sleep(1);      NSLog(@&quot;异步任务2&quot;);    dispatch_group_leave(group);});// 等待group中多个异步任务执行完毕，做一些事情，介绍两种方式// 方式2（比较好）dispatch_group_notify(group, dispatch_get_main_queue(), ^{    // 任务完成后，在主队列中做一些操作      NSLog(@&quot;完成任务&quot;);});</code></pre><p> 以上达到理想，执行完任务1 和任务2 再执行notify ,输出任务完成。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">5. dispatch_barrier_async </span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">dispatch_barrier_async的作用可以用一个词概括－－承上启下，它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。本例中，任务4会在任务1、2、3都执行完之后执行，而任务5、6会等待任务4执行完后执行。</span><br><span class="line">***</span><br></pre></td></tr></table></figure></p><pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{    // 任务1    ...});dispatch_async(queue, ^{    // 任务2    ...});dispatch_async(queue, ^{    // 任务3    ...});dispatch_barrier_async(queue, ^{    // 任务4    ...});dispatch_async(queue, ^{    // 任务5    ...});dispatch_async(queue, ^{    // 任务6    ...}); <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意事项   </span><br><span class="line">和dispatch_group类似，dispatch_barrier也是异步任务间的一种同步方式，可以在比如文件的读写操作时使用，保证读操作的准确性。另外，有一点需要注意，dispatch_barrier_sync和dispatch_barrier_async只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</span><br><span class="line"></span><br><span class="line">6. dispatch_apply</span><br></pre></td></tr></table></figure>// for循环做一些事情，输出0123456789</code></pre><p>for (int i = 0; i &lt; 10; i ++) {<br>    NSLog(@”%d”, i);<br>}</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> dispatch_apply替换（当且仅当处理顺序对处理结果无影响环境），输出顺序不定，比如1098673452   </span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></code></pre><p>/<em>! dispatch_apply函数说明</em></p><ul><li>@brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API</li><li>该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束<br>*</li><li>@param 10    指定重复次数  指定10次</li><li>@param queue 追加对象的Dispatch Queue</li><li><p>@param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block<br><em></em>/<br>dispatch_apply(10, queue, ^(size_t index) {<br> NSLog(@”%zu”, index);<br>});</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line">应用场景</span><br><span class="line">那么，dispatch_apply有什么用呢，因为dispatch_apply并行的运行机制，效率一般快于for循环的类串行机制（在for一次循环中的处理任务很多时差距比较大）。比如这可以用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性，如果用for循环，耗时较多，并且每个表单的数据没有依赖关系，所以用dispatch_apply比较好。</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">7. dispatch_suspend和dispatch_resume</span><br></pre></td></tr></table></figure><p> dispatch_queue_t queue = dispatch_get_main_queue();<br> dispatch_suspend(queue); //暂停队列queue<br> dispatch_resume(queue);  //恢复队列queue</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line">应用场景</span><br><span class="line">这种用法我还没有尝试过，不过其中有个需要注意的点。这两个函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*拾遗*</span><br><span class="line"></span><br><span class="line">1. 死锁</span><br><span class="line"></span><br><span class="line">dispatch_sync</span><br></pre></td></tr></table></figure><p> // 假设这段代码执行于主队列<br> dispatch_queue_t serialQueue = dispatch_queue_create(“serialQueue”, DISPATCH_QUEUE_SERIAL);<br> dispatch_queue_t mainQueue = dispatch_get_main_queue();</p><p> // 在主队列添加同步任务<br> dispatch_sync(mainQueue, ^{</p><pre><code>// 任务...</code></pre><p> });</p><p> // 在串行队列添加同步任务<br> dispatch_sync(serialQueue, ^{</p><pre><code>// 任务...dispatch_sync(serialQueue, ^{    // 任务    ...});</code></pre><p> };</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_apply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">// 因为dispatch_apply会卡住当前线程，内部的dispatch_apply会等待外部，外部的等待内部，所以死锁。</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t) &#123;</span><br><span class="line">    // 任务</span><br><span class="line">    ...</span><br><span class="line">    dispatch_apply(10, queue, ^(size_t) &#123;</span><br><span class="line">        // 任务</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>dispatch_time_t</li></ol><ul><li>dispatch_time_t一般在dispatch_after和dispatch_group_wait等方法里作为参数使用。这里最需要注意的是一些宏的含义。   </li><li>NSEC_PER_SEC，每秒有多少纳秒。   </li><li>USEC_PER_SEC，每秒有多少毫秒。   </li><li>NSEC_PER_USEC，每毫秒有多少纳秒。   </li><li>DISPATCH_TIME_NOW 从现在开始   </li><li>DISPATCH_TIME_FOREVE 永久   </li></ul><p><em>time为1s的写法</em><br>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
